#define _CRT_SECURE_NO_WARNINGS

/*浮点型数据的存储*/

//先由一段代码来抛砖引玉

//#include<stdio.h>
//int main()
//{
//	int n = 9;
//	float* pFLOAT = (float*)&n;
//
//	printf("p的值为：%d\n", n);            //p的值为：9
//
//	printf("*pFLOAT的值为：%f\n", *pFLOAT);//* pFLOAT的值为：0.000000
//
//	*pFLOAT = 9.0;
//	printf("n的值为:%d\n", n);             //n的值为:1091567616
//
//	printf("*pFLOAT的值为：%f\n", *pFLOAT);//* pFLOAT的值为：9.000000
//
//	return 0;
//}
//为什么会产生这样的结果？
//来仔细分析一下，第十行，9以整型的方式存储，在13行以整型的方式打印，结果没有问题，然而在15行以浮点数的形式打印，结果超出预期
//而当我以浮点数的形式存放，再以浮点数的形式取出打印，和以整型的方式取出打印的结果大相径庭，
//因此，可以初步下一个定论：浮点数在内存中的存储方式和取出方式和整型数据由较大差异

//而差异的来源在于 IEEE 754标准。

//IEEE 754标准，全称为IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985），又称IEC 60559:1989，微处理器系统的二进制浮点数算术（本来的编号是IEC 559:1989）。
//任意一个二进制浮点数V可以表示成下面的形式:
//        (-1) ^ S * M * 2 ^ E
//        (-1) ^ s 表示符号位，当s = 0，V为正数; 当s = 1，V为负数, 与整型符号位的概念相似
//        M 表示有效数字，大于等于1，小于2。
//        2 ^ E 表示指数位。
//举例来说 : 十进制的5.0，写成二进制是   101.0，相当于1.01 * 2 ^ 2。那么，按照上面V的格式，可以得出S = 0, M = 1.01，E = 2。
//         十进制的 -5.0，写成二进制是 - 101.0，相当于 - 1.01 * 2 ^ 2 。那么，S = 1，M = 1.01，E = 2.


//IEEE 754规定:对于 32 位的浮点数(即  float)，最高的1位是符号位s，接着的 8  位是指数E，剩下的 23 位为有效数字M.
//             对于 64 位的浮点数(即 double)，最高的1位是符号位s，接着的 11 位是指数E，剩下的 52 位为有效数字M.
//

//IEEE 754对有效数字M和指数E，还有一些特别规定。前面说过，1 <= M <= 2，也就是说，M可以写成1.xxxxxx 的形式，其中xxxxxx表示小数部分。
//IEEE 754规定，在计算机内部保存 M 时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分
//比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。
//这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。


//至于指数 E ，情况比较复杂

//E的存储;
//首先，E 为一个无符号整数，这意味着，如果 E 为8位，那么它的取值范围为 0~255；如果 E 为8位，那么它的取值范围为 0~2047。
//但是，我们都知道，科学计数法中的E是可以出现负数的，因此，存入内存的E的真实值必须加上一个中间值。
//对于8位（float）的E，这个中间数是 127；对于11位（double），这个中间数是1023。
//比如，2 ^ 10的E是10，保存成32位浮点数时，必须保存成10 + 127 = 137，即10001001。

//E的取出：

//1. E不全为0或不全为1
//此时遵守规则：E的计算值减去127（1023），得到真实值，再将有效数字M前加上第一位的1。
//比如：0.5（1/2）的二进制形式为0.1，规定整数部分必须大于1，则写成：1.0 * 2 ^（-1）
//其阶码为-1 + 127 = 126，表示为01111110
//去1，剩下为0，补齐0到23位00000000000000000000000
//0.5的二进制表示方法为0 01111110 00000000000000000000000

//2. E全为0
//浮点数的指数E = 1 - 127（1 - 1023）作为真实值，有效数字M不在加上第一位而是还原为0.xxxxxxxxxxx的小数。
// 这样做的目的是为了表示±0，以及非常接近于0的数字。

//3. E全为1
//这时，这个值被定义为无穷，表示±无穷大（正负号取决于符号位s）


#include<stdio.h>
int main()
{
	int n = 9;
	//二进制表示为：
	//00000000000000000000000000001001
	float* pFLOAT = (float*)&n;

	printf("p的值为：%d\n", n);            //p的值为：9
	//00000000000000000000000000001001
	//以整数形式打印为9

	printf("*pFLOAT的值为：%f\n", *pFLOAT);//* pFLOAT的值为：0.000000
	//0 00000000 00000000000000000001001
	//符号位为0，正数
	//指数位全为0，真实值为1 - 127 = -126
	//有效数字为0.00000000000000000001001
	//表示为（-1）* 0(s) * 0.00000000000000000001001(M) * 2 ^ -126(E)
	//单精度浮点数默认打印小数点后六位即0.000000

	*pFLOAT = 9.0;
	printf("n的值为:%d\n", n);             //n的值为:1091567616
	//9.0的二进制表现形式为 1001.0
	//浮点数表现形式为0 10000010 00100000000000000000000
	//把它按整型方式取出的话为1091567616

	printf("*pFLOAT的值为：%f\n", *pFLOAT);//* pFLOAT的值为：9.000000
	//按浮点数的方式取出的话为9.000000

	return 0;
}
