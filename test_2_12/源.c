#define _CRT_SECURE_NO_WARNINGS

/*数据存储*/

//首先我们来看一下数据的大致分类：
//1.整型家族：char  -  signed cahr (有符号) / unsigned char (无符号)
//            char  -  signed short(有符号) / unsigned short(无符号)
//            int   -  signed int  (有符号) / unsigned int  (无符号)
//            long  -  signed long (有符号) / unsigned long (无符号)

//2.浮点型家族： float 
//               double

//3.构造类型(又称:自定义类型)家族：
//          数组类型   -   int arr[]
//          结构体类型 -   struct
//          枚举类型   -   enum
//          联合类型   -   union

//4.指针类型：
//    int * p1;
//    char * p2;
//    short * p3;
//    float * p4;
//    void * p5;

//空类型(void):
//函数返回类型：void test():
//函数参数：void test(void):
//指针： void* p;

/*数据在内存中都是以二进制的形式存放，其中整型的存放较为特殊，我们先来详细的了解一下整型的三种表现形式：原码，反码，补码*/

//正整数，原码，反码，补码都相同；
//负整数，原码，反码（原码除符号位以外的位取反），补码（反码 + 1）；

/*
CSDN上的这篇博客详细的讲述了补码的产生，作用，意义，
https://blog.csdn.net/mkr67n/article/details/114701908?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_re
levant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114701908-blog-62051591.pc_relevant_recovery_v2&depth_1-
utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-114701908-blog-62051591.pc_rele
vant_recovery_v2&utm_relevant_index=1

*/

/*大小端介绍*/

//1.什么是大端小端:
//大端(存储)模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中，
//小端(存储)模式，是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中

//为什么有大端和小端 :

//这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着个字节，一个字节为8bit。
//但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型(要看具体的编译器)，
//另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。
//因此就导致了大端存储模式和小端存储模式。
//
//例如 - 个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。
//对于大端模式，就将0x11 放在低地址中，即 0x0010 中，0x22放在高地址中，即 0x0011中。小端模式，刚好相反。
//我们常用的x86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。
//有些ARM处理器还可以由硬件来选择是大端模式还是小端模式

//下面以百度2015年的系统工程师笔试题来加深一下了解

//请简述一下大端字节序和小端字节序的概念，并写一个程序来判断系统使用的是大端还是小端。

//#include<stdio.h>
//int main()
//{
//	int i = 1;
//	//00000000000000000000000000000001
//	//01 00 00 00 - 小端 或者 00 00 00 01 - 大端
//
//	char* p = &i;
//
//	if (*p == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//
//	return 0;
//}


/*数据存储例题*/

//#include<stdio.h>
//int main()
//{
//	char a = -1;
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	//11111111
//	signed char b = -1;
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	//11111111
//	unsigned char c = -1;
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	//11111111
//
//	printf("a=%d, b=%d, c=%d", a, b, c);//-1 -1 255
//	//a和b本质上是一样的，以a为例
//	//11111111111111111111111111111111 - a补
//	//11111111111111111111111111111110 - a反
//	//10000000000000000000000000000001 - a原
//
//	//无符号类型补零
//	//00000000000000000000000011111111 - c补
//	//补完后看最高位-> 0，
//	//结论：正数，原反补相同。
//	//11111111 = 255
//	return 0;
//}

//#include<stdio.h>
//int main()
//{
//	char a = -128;//2^7
//	//10000000000000000000000010000000 - 原
//	//11111111111111111111111101111111 - 反
//	//11111111111111111111111100000000 - 补
//	//100000000
//	printf("a = %u", a);//4294967168
//	//按char类型整型提升
//	//11111111111111111111111110000000 - 补
//	//计算机认为这个补码是无符号数，无符号位概念，原反补相同
//
//	return 0;
//}

//#include<stdio.h>
//int main()
//{
//	char a = 128;
//	//00000000000000000000000010000000
//	//正数，原反补相同
//	//10000000
//	printf("a = %d", a);
//	//10000000
//	// 按a原来的类型提升，char是有符号的
//	//11111111111111111111111110000000
//
//	return 0;
//
//}


//
//char类型的取值范围 -128~127
//

#include<stdio.h>
//int main()
//{
//	int i = -20;
//	//10000000000000000000000000010100
//	//11111111111111111111111111101011
//	//11111111111111111111111111101100
//	unsigned int j = 10;
//	//00000000000000000000000000001010
//	printf("%d\n", i + j);
//	//00000000000000000000000000001010
//	//11111111111111111111111111101100
//	//11111111111111111111111111110110
//
//	//11111111111111111111111111110101
//	//10000000000000000000000000001010  -10？
//	return 0;
//}

//int main()
//{
//	unsigned int i = 0;
//	for (i = 9; i >= 0; i--)//无符号数必定大于零，死循环！
//	{
//		printf("%u\n", i);
//	}
//
//	return 0;
//}

//#include<string.h>
//int main()
//{
//	char a[1000];
//	int i = 0;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d\n", strlen(a));//为什么是255？
//
//	return 0;
//}//-1 -2 -3 …… -127 -128 127 126 …… 3 2 1 0 -1 -2 - 3 …… -127 -128 127 …… 像一个圆一样轮回
//从 -1 开始第一次读取到 字符零 时，strlen（）函数停止读取，0 前有255个元素，

//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//
//	return 0;
//}
//当i=255时，i+1=0，再次重复循环，继而造成死循环